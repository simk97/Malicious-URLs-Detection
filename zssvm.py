# -*- coding: utf-8 -*-
"""ZSSVM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JjSCK8r0c33_icTWEVLbtDm5j5Ga8ONm
"""

from google.colab import files
uploaded = files.upload()

import pandas as pd
import matplotlib.pyplot as plt
import random
import numpy as np
from sklearn import preprocessing
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.feature_extraction.text import TfidfVectorizer
import io

Datacsv = pd.read_csv(io.BytesIO(uploaded['data.csv']),',')
Datadf = pd.DataFrame(Datacsv)
print(Datadf.shape)
print(Datadf.describe(include = 'all'))

df_filtered = Datadf[(Datadf['is_goal'].isnull())]

TestData = df_filtered
TestData.drop('is_goal', axis = 1, inplace = True)
TrainData = pd.concat([df_filtered, Datadf]).drop_duplicates(keep=False)

print(TrainData.shape)
print(TestData.shape)
print(TrainData.head())
print(TestData.head())

Datadf1 = TrainData.drop(['shot_id_number', 'Unnamed: 0'], axis= 1)

defaultString = 'NaN'
stringFeatures = ['area_of_shot', 'date_of_game', 'game_season', 'home/away', 'lat/lng', 'range_of_shot', 'shot_basics', 'team_name', 'type_of_combined_shot', 'type_of_shot']
for feature in Datadf1:
    if feature in stringFeatures:
        Datadf1[feature] = Datadf1[feature].fillna(defaultString)
Datadf1.fillna(0, inplace = True)

for feature in Datadf1:
    le = preprocessing.LabelEncoder()
    le.fit(Datadf1[feature])
    le_name_mapping = dict(zip(le.classes_, le.transform(le.classes_)))
    Datadf1[feature] = le.transform(Datadf1[feature])

Datadf1.head()

fitcols = ['area_of_shot', 'date_of_game', 'distance_of_shot',
       'distance_of_shot.1', 'game_season', 'home/away', 
       'knockout_match.1', 'lat/lng', 'location_x',
       'location_y', 'match_id', 'power_of_shot', 'power_of_shot.1',
       'range_of_shot', 'remaining_min', 'remaining_min.1', 'remaining_sec',
       'remaining_sec.1', 'shot_basics', 'match_event_id','type_of_combined_shot', 'type_of_shot']
from sklearn.model_selection import train_test_split
from sklearn import preprocessing
from sklearn.datasets import make_classification
from sklearn.preprocessing import binarize, LabelEncoder, MinMaxScaler
scaler = MinMaxScaler()
for col in fitcols:
  Datadf1[col] = scaler.fit_transform(Datadf1[[col]])

Datadf1.head()

feature_cols = ['area_of_shot', 'date_of_game', 'distance_of_shot',
       'distance_of_shot.1', 'game_season', 'home/away', 
       'knockout_match', 'knockout_match.1', 'lat/lng', 'location_x',
       'location_y', 'match_id', 'power_of_shot', 'power_of_shot.1',
       'range_of_shot', 'remaining_min', 'remaining_min.1', 'remaining_sec',
       'remaining_sec.1', 'shot_basics', 'match_event_id', 'team_id',
       'team_name', 'type_of_combined_shot', 'type_of_shot']

X = Datadf1[feature_cols]
y = Datadf1.is_goal

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=0)

from sklearn.metrics import accuracy_score
from sklearn.metrics import roc_auc_score
from sklearn.model_selection import cross_val_score
from sklearn.ensemble import GradientBoostingClassifier  
from sklearn.model_selection import cross_validate
from sklearn.neighbors import KNeighborsClassifier
from sklearn import svm

clf = svm.SVC(gamma = 'scale',probability=True).fit(X_train,y_train)
clf.fit(X_train,y_train)
y_pred=clf.predict(X_test)

from sklearn import metrics
from sklearn.model_selection import cross_validate
cv_score = cross_validate(clf, X_test, y_test, cv=5, scoring='roc_auc')

print("Accuracy : " ,metrics.accuracy_score(y_test.values, y_pred))
print("CV Score - " , cv_score)

TestData1 = TestData.drop(['shot_id_number', 'Unnamed: 0'], axis= 1)
defaultString = 'NaN'
stringFeatures = ['area_of_shot', 'date_of_game', 'game_season', 'home/away', 'lat/lng', 'range_of_shot', 'shot_basics', 'team_name', 'type_of_combined_shot', 'type_of_shot']
for feature in TestData1:
    if feature in stringFeatures:
        TestData1[feature] = TestData1[feature].fillna(defaultString)
TestData1.fillna(0, inplace = True)

for feature in TestData1:
    le = preprocessing.LabelEncoder()
    le.fit(TestData1[feature])
    le_name_mapping = dict(zip(le.classes_, le.transform(le.classes_)))
    TestData1[feature] = le.transform(TestData1[feature])

fitcols = ['area_of_shot', 'date_of_game', 'distance_of_shot',
       'distance_of_shot.1', 'game_season', 'home/away', 
       'knockout_match.1', 'lat/lng', 'location_x',
       'location_y', 'match_id', 'power_of_shot', 'power_of_shot.1',
       'range_of_shot', 'remaining_min', 'remaining_min.1', 'remaining_sec',
       'remaining_sec.1', 'shot_basics', 'match_event_id','type_of_combined_shot', 'type_of_shot']
from sklearn.model_selection import train_test_split
from sklearn import preprocessing
from sklearn.datasets import make_classification
from sklearn.preprocessing import binarize, LabelEncoder, MinMaxScaler
scaler = MinMaxScaler()
for col in fitcols:
  TestData1[col] = scaler.fit_transform(TestData1[[col]])

predictions = clf.predict(TestData1)
predprob = clf.predict_proba(TestData1)[:,1]

Result = pd.DataFrame()
Result['shot_id_number'] = TestData['shot_id_number']
Result['is_goal'] = predprob

Result.set_index('shot_id_number', inplace = True)
Result.head()

Result.to_csv('ZSLR.csv')
files.download('ZSLR.csv')